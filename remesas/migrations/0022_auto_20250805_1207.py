# Generated by Django 5.2.4 on 2025-08-05 16:07

from django.db import migrations
from datetime import datetime


def generar_id_pago_nuevo_formato(tipo_pago='transferencia', cantidad=0):
    """Genera un ID único para el pago con el nuevo formato durante la migración"""
    ahora = datetime.now()
    mes = f"{ahora.month:02d}"
    dia = f"{ahora.day:02d}"
    # Usar la cantidad en lugar de número aleatorio
    cantidad_str = f"{int(cantidad):03d}" if cantidad else "000"
    hora = f"{ahora.hour:02d}{ahora.minute:02d}{ahora.second:02d}"
    # T para transferencia, E para efectivo
    tipo_letra = 'T' if tipo_pago == 'transferencia' else 'E'
    return f"PAGO-{mes}/{dia}-{tipo_letra}{cantidad_str}-{hora}"


def generar_id_remesa_nuevo_formato(metodo_pago='transferencia', cantidad=0):
    """Genera un ID único para la remesa con el nuevo formato durante la migración"""
    ahora = datetime.now()
    mes = f"{ahora.month:02d}"
    dia = f"{ahora.day:02d}"
    # Usar la cantidad en lugar de número aleatorio
    cantidad_str = f"{int(cantidad):03d}" if cantidad else "000"
    hora = f"{ahora.hour:02d}{ahora.minute:02d}{ahora.second:02d}"
    # T para transferencia, E para efectivo
    tipo_letra = 'T' if metodo_pago == 'transferencia' else 'E'
    return f"REM-{mes}/{dia}-{tipo_letra}{cantidad_str}-{hora}"


def actualizar_ids_con_cantidad(apps, schema_editor):
    """Actualiza los IDs existentes para usar la cantidad en lugar de números aleatorios"""
    Pago = apps.get_model('remesas', 'Pago')
    Remesa = apps.get_model('remesas', 'Remesa')
    
    # Actualizar pagos existentes
    for pago in Pago.objects.all():
        cantidad = float(pago.cantidad) if pago.cantidad else 0
        nuevo_id = generar_id_pago_nuevo_formato(pago.tipo_pago, cantidad)
        
        # Verificar que el ID sea único
        contador = 1
        id_original = nuevo_id
        while Pago.objects.filter(pago_id=nuevo_id).exclude(pk=pago.pk).exists():
            # Si no es único, agregar un sufijo
            ahora = datetime.now()
            hora_modificada = f"{ahora.hour:02d}{ahora.minute:02d}{(ahora.second + contador):02d}"
            nuevo_id = f"{id_original[:-6]}{hora_modificada}"
            contador += 1
        
        pago.pago_id = nuevo_id
        pago.save()
    
    # Actualizar remesas existentes que no tengan ID
    for remesa in Remesa.objects.filter(remesa_id__isnull=True):
        # Determinar el tipo de método de pago
        metodo_pago_tipo = 'transferencia'  # por defecto
        if remesa.metodo_pago:
            nombre_metodo = remesa.metodo_pago.nombre.lower()
            if 'efectivo' in nombre_metodo or 'cash' in nombre_metodo:
                metodo_pago_tipo = 'efectivo'
        
        cantidad = float(remesa.importe) if remesa.importe else 0
        nuevo_id = generar_id_remesa_nuevo_formato(metodo_pago_tipo, cantidad)
        
        # Verificar que el ID sea único
        contador = 1
        id_original = nuevo_id
        while Remesa.objects.filter(remesa_id=nuevo_id).exclude(pk=remesa.pk).exists():
            ahora = datetime.now()
            hora_modificada = f"{ahora.hour:02d}{ahora.minute:02d}{(ahora.second + contador):02d}"
            nuevo_id = f"{id_original[:-6]}{hora_modificada}"
            contador += 1
        
        remesa.remesa_id = nuevo_id
        remesa.save()


def revertir_actualizacion_ids(apps, schema_editor):
    """Revierte la actualización de IDs (para rollback)"""
    # No hacer nada en el rollback para preservar los datos
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('remesas', '0021_alter_remesa_remesa_id'),
    ]

    operations = [
        migrations.RunPython(actualizar_ids_con_cantidad, revertir_actualizacion_ids),
    ]
